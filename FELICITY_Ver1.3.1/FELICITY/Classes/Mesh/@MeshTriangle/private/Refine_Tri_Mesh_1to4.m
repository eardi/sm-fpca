function [New_Vtx_Coord, New_Tri_List, New_Subdomain] =...
                         Refine_Tri_Mesh_1to4(Vtx_Coord,Edge_List,Tri_List,Subdomain)
%Refine_Tri_Mesh_1to4
%
%   This routine takes a given Triangle Mesh and refines ALL triangles using
%   1-to-4 refinement (for 2D triangulations only).
%
%   [New_Vtx_Coord, New_Tri_List, New_Subdomain] =...
%            Refine_Tri_Mesh_1to4(Vtx_Coord,Edge_List,Tri_List,Subdomain);
%
%   Vtx_Coord = coordinates of mesh vertices.
%   Edge_List = connectivity of edges in mesh (indexes into Vtx_Coord).
%   Tri_List  = connectivity of triangles in mesh (indexes into Vtx_Coord).
%   Subdomain = array of Subdomain structs (see 'Create_Subdomain' in the
%               'AbstractMesh' class for their format).
%
%   New_Vtx_Coord = same as 'Vtx_Coord' except for the refined mesh.
%   New_Tri_List  = same as 'Tri_List' except for the refined mesh.
%   New_Subdomain = same as 'Subdomain' except for the refined mesh.

% Copyright (c) 02-18-2013,  Shawn W. Walker

% sort it for convenience
Sorted_Edge_List = sort(Edge_List,2); % yes you need it (just in case)

% first compute the locations of the new vertices (these are additional)
Num_Old_Vtx = size(Vtx_Coord,1);
% note: Edge_List is a global list of ALL mesh edges
New_Vtx = 0.5 * ( Vtx_Coord(Sorted_Edge_List(:,1),:) + Vtx_Coord(Sorted_Edge_List(:,2),:) );
New_Vtx_Ind = (1:1:size(New_Vtx,1))' + Num_Old_Vtx;
% note that the new vertices correspond directly to the OLD (global) edge list
New_Vtx_Coord = [Vtx_Coord; New_Vtx];

% need to know what edges are shared by each triangle
% i.e. we need to know the correspondance between the three local edges of each
% triangle and the global edge list
[TF1, LOC1] = ismember(sort(Tri_List(:,[1 2]),2),Sorted_Edge_List,'rows');
[TF2, LOC2] = ismember(sort(Tri_List(:,[2 3]),2),Sorted_Edge_List,'rows');
[TF3, LOC3] = ismember(sort(Tri_List(:,[3 1]),2),Sorted_Edge_List,'rows');

if or(or(min(TF1)==0,min(TF2)==0),min(TF3)==0)
    error('Some triangle edges were NOT found in Edge_List!  This should NOT happen!');
end

% % % generate new edge list (each corresponds to OLD edge list)
% % %Num_Old_Edge = size(Edge_List,1);
% % New_Edge1 = [Edge_List(:,1), New_Vtx_Ind];
% % New_Edge2 = [New_Vtx_Ind, Edge_List(:,2)];

% so each global edge gets bisected into two pieces; a "tail" piece and a "head"
% piece (i.e. the "tail" piece has the same "tail" vertex as the father edge,
% and likewise with the "head" piece).

% more new edges that correspond to OLD triangle list
% these are the "internal" edges generated by the 1-to-4 refinement
New_Interior_Edge1 = [New_Vtx_Ind(LOC1,1), New_Vtx_Ind(LOC3,1)];
New_Interior_Edge2 = [New_Vtx_Ind(LOC2,1), New_Vtx_Ind(LOC1,1)];
New_Interior_Edge3 = [New_Vtx_Ind(LOC3,1), New_Vtx_Ind(LOC2,1)];

% generate new triangle list
% each new triangle list directly corresponds to the original triangle list
% (before refinement)
Num_Old_Tri = size(Tri_List,1);
New_Tri1 = [Tri_List(:,1), New_Interior_Edge1];
New_Tri2 = [Tri_List(:,2), New_Interior_Edge2];
New_Tri3 = [Tri_List(:,3), New_Interior_Edge3];
New_Tri4 = [New_Vtx_Ind(LOC1,1), New_Vtx_Ind(LOC2,1), New_Vtx_Ind(LOC3,1)];

% concatenate
New_Tri_List = [New_Tri1; New_Tri2; New_Tri3; New_Tri4];
% % concatenate
% %New_Edge_List = [New_Edge1; New_Edge2; New_Interior_Edge1; New_Interior_Edge2; New_Interior_Edge3];

% don't forget to refine subdomains
if ~isempty(Subdomain)
    New_Subdomain = Subdomain(1); % just init
    for ind = 1:length(Subdomain)
        if (Subdomain(ind).Dim==0)
            New_Subdomain(ind) = Refine_Subdomain_0D(Subdomain(ind),Num_Old_Tri);
        elseif (Subdomain(ind).Dim==1)
            New_Subdomain(ind) = Refine_Subdomain_1D(Subdomain(ind),Num_Old_Tri);
        elseif (Subdomain(ind).Dim==2)
            New_Subdomain(ind) = Refine_Subdomain_2D(Subdomain(ind),Num_Old_Tri);
        end
    end
else
    New_Subdomain = [];
end

end